// // Copyright (c) 2024 by Rockchip Electronics Co., Ltd. All Rights Reserved.
// //
// // Licensed under the Apache License, Version 2.0 (the "License");
// // you may not use this file except in compliance with the License.
// // You may obtain a copy of the License at
// //
// //     http://www.apache.org/licenses/LICENSE-2.0
// //
// // Unless required by applicable law or agreed to in writing, software
// // distributed under the License is distributed on an "AS IS" BASIS,
// // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// // See the License for the specific language governing permissions and
// // limitations under the License.

// #include <string.h>
// #include <unistd.h>
// #include <string>
// #include "rkllm.h"
// #include <fstream>
// #include <iostream>
// #include <csignal>
// #include <vector>

// #define PROMPT_TEXT_PREFIX "<｜begin▁of▁sentence｜><｜User｜>"
// #define PROMPT_TEXT_POSTFIX "<｜Assistant｜>"

// using namespace std;
// LLMHandle llmHandle = nullptr;

// void exit_handler(int signal)
// {
//     if (llmHandle != nullptr)
//     {
//         {
//             cout << "程序即将退出" << endl;
//             LLMHandle _tmp = llmHandle;
//             llmHandle = nullptr;
//             rkllm_destroy(_tmp);
//         }
//     }
//     exit(signal);
// }

// void callback(RKLLMResult *result, void *userdata, LLMCallState state)
// {
//     if (state == RKLLM_RUN_FINISH)
//     {
//         printf("\n");
//     } else if (state == RKLLM_RUN_ERROR) {
//         printf("\\run error\n");
//     } else if (state == RKLLM_RUN_GET_LAST_HIDDEN_LAYER) {
//         /* ================================================================================================================
//         若使用GET_LAST_HIDDEN_LAYER功能,callback接口会回传内存指针:last_hidden_layer,token数量:num_tokens与隐藏层大小:embd_size
//         通过这三个参数可以取得last_hidden_layer中的数据
//         注:需要在当前callback中获取,若未及时获取,下一次callback会将该指针释放
//         ===============================================================================================================*/
//         if (result->last_hidden_layer.embd_size != 0 && result->last_hidden_layer.num_tokens != 0) {
//             int data_size = result->last_hidden_layer.embd_size * result->last_hidden_layer.num_tokens * sizeof(float);
//             printf("\ndata_size:%d",data_size);
//             std::ofstream outFile("last_hidden_layer.bin", std::ios::binary);
//             if (outFile.is_open()) {
//                 outFile.write(reinterpret_cast<const char*>(result->last_hidden_layer.hidden_states), data_size);
//                 outFile.close();
//                 std::cout << "Data saved to output.bin successfully!" << std::endl;
//             } else {
//                 std::cerr << "Failed to open the file for writing!" << std::endl;
//             }
//         }
//     } else if (state == RKLLM_RUN_NORMAL) {
//         printf("%s", result->text);
//     }
// }

// int main(int argc, char **argv)
// {
//     if (argc < 4) {
//         std::cerr << "Usage: " << argv[0] << " model_path max_new_tokens max_context_len\n";
//         return 1;
//     }

//     signal(SIGINT, exit_handler);
//     printf("rkllm init start\n");

//     //设置参数及初始化
//     RKLLMParam param = rkllm_createDefaultParam();
//     param.model_path = argv[1];

//     //设置采样参数
//     param.top_k = 1;
//     param.top_p = 0.95;
//     param.temperature = 0.8;
//     param.repeat_penalty = 1.1;
//     param.frequency_penalty = 0.0;
//     param.presence_penalty = 0.0;

//     param.max_new_tokens = std::atoi(argv[2]);
//     param.max_context_len = std::atoi(argv[3]);
//     param.skip_special_token = true;
//     param.extend_param.base_domain_id = 0;

//     int ret = rkllm_init(&llmHandle, &param, callback);
//     if (ret == 0){
//         printf("rkllm init success\n");
//     } else {
//         printf("rkllm init failed\n");
//         exit_handler(-1);
//     }

//     vector<string> pre_input;
//     pre_input.push_back("现有一笼子，里面有鸡和兔子若干只，数一数，共有头14个，腿38条，求鸡和兔子各有多少只？");
//     pre_input.push_back("有28位小朋友排成一行,从左边开始数第10位是学豆,从右边开始数他是第几位?");
//     cout << "\n**********************可输入以下问题对应序号获取回答/或自定义输入********************\n"
//          << endl;
//     for (int i = 0; i < (int)pre_input.size(); i++)
//     {
//         cout << "[" << i << "] " << pre_input[i] << endl;
//     }
//     cout << "\n*************************************************************************\n"
//          << endl;

//     string text;
//     RKLLMInput rkllm_input;

//     // 初始化 infer 参数结构体
//     RKLLMInferParam rkllm_infer_params;
//     memset(&rkllm_infer_params, 0, sizeof(RKLLMInferParam));  // 将所有内容初始化为 0

//     // 1. 初始化并设置 LoRA 参数（如果需要使用 LoRA）
//     // RKLLMLoraAdapter lora_adapter;
//     // memset(&lora_adapter, 0, sizeof(RKLLMLoraAdapter));
//     // lora_adapter.lora_adapter_path = "qwen0.5b_fp16_lora.rkllm";
//     // lora_adapter.lora_adapter_name = "test";
//     // lora_adapter.scale = 1.0;
//     // ret = rkllm_load_lora(llmHandle, &lora_adapter);
//     // if (ret != 0) {
//     //     printf("\nload lora failed\n");
//     // }

//     // 加载第二个lora
//     // lora_adapter.lora_adapter_path = "Qwen2-0.5B-Instruct-all-rank8-F16-LoRA.gguf";
//     // lora_adapter.lora_adapter_name = "knowledge_old";
//     // lora_adapter.scale = 1.0;
//     // ret = rkllm_load_lora(llmHandle, &lora_adapter);
//     // if (ret != 0) {
//     //     printf("\nload lora failed\n");
//     // }

//     // RKLLMLoraParam lora_params;
//     // lora_params.lora_adapter_name = "test";  // 指定用于推理的 lora 名称
//     // rkllm_infer_params.lora_params = &lora_params;

//     // 2. 初始化并设置 Prompt Cache 参数（如果需要使用 prompt cache）
//     // RKLLMPromptCacheParam prompt_cache_params;
//     // prompt_cache_params.save_prompt_cache = true;                  // 是否保存 prompt cache
//     // prompt_cache_params.prompt_cache_path = "./prompt_cache.bin";  // 若需要保存prompt cache, 指定 cache 文件路径
//     // rkllm_infer_params.prompt_cache_params = &prompt_cache_params;
    
//     // rkllm_load_prompt_cache(llmHandle, "./prompt_cache.bin"); // 加载缓存的cache

//     rkllm_infer_params.mode = RKLLM_INFER_GENERATE;

//     while (true)
//     {
//         std::string input_str;
//         printf("\n");
//         printf("user: ");
//         std::getline(std::cin, input_str);
//         if (input_str == "exit")
//         {
//             break;
//         }
//         for (int i = 0; i < (int)pre_input.size(); i++)
//         {
//             if (input_str == to_string(i))
//             {
//                 input_str = pre_input[i];
//                 cout << input_str << endl;
//             }
//         }
//         text = PROMPT_TEXT_PREFIX + input_str + PROMPT_TEXT_POSTFIX;
//         // text = input_str;
//         rkllm_input.input_type = RKLLM_INPUT_PROMPT;
//         rkllm_input.prompt_input = (char *)text.c_str();
//         printf("robot: ");

//         // 若要使用普通推理功能,则配置rkllm_infer_mode为RKLLM_INFER_GENERATE或不配置参数
//         rkllm_run(llmHandle, &rkllm_input, &rkllm_infer_params, NULL);
//     }
//     rkllm_destroy(llmHandle);

//     return 0;
// }